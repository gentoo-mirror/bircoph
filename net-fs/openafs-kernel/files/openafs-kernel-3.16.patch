commit ae86b07f827d6f3e2032a412f5f6cb3951a27d2d
Author: Marc Dionne <marc.dionne@your-file-system.com>
Date:   Wed Jun 18 08:53:48 2014 -0400

    Linux 3.16: Switch to iter_file_splice_write
    
    Users of generic_file_splice_write need to switch to
    using iter_file_splice_write.
    
    Reviewed-on: http://gerrit.openafs.org/11302
    Reviewed-by: Chas Williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
    Tested-by: Chas Williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
    Reviewed-by: Jeffrey Altman <jaltman@your-file-system.com>
    Tested-by: Jeffrey Altman <jaltman@your-file-system.com>
    (cherry picked from commit e284db57f94c8f97ed1c95dcd0bd9518d86c050c)
    
    Change-Id: I6f88ec0388fe43accc150c7243c1a474c9e643af
    Reviewed-on: http://gerrit.openafs.org/11308
    Reviewed-by: Chas Williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    Reviewed-by: Stephan Wiesand <stephan.wiesand@desy.de>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>

diff --git a/acinclude.m4 b/acinclude.m4
index 012d5a4..83a1a8c 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -917,6 +917,9 @@ case $AFS_SYSNAME in *_linux* | *_umlinux*)
 		 AC_CHECK_LINUX_FUNC([inode_setattr],
 				     [#include <linux/fs.h>],
 				     [inode_setattr(NULL, NULL);])
+		 AC_CHECK_LINUX_FUNC([iter_file_splice_write],
+				     [#include <linux/fs.h>],
+				     [iter_file_splice_write(NULL,NULL,NULL,0,0);])
 		 AC_CHECK_LINUX_FUNC([kernel_setsockopt],
 				     [#include <linux/net.h>],
 				     [kernel_setsockopt(NULL, 0, 0, NULL, 0);])
diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index 86905c7..441cce7 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -812,7 +812,11 @@ struct file_operations afs_file_fops = {
   .sendfile =   generic_file_sendfile,
 #endif
 #if defined(STRUCT_FILE_OPERATIONS_HAS_SPLICE)
+# if defined(HAVE_LINUX_ITER_FILE_SPLICE_WRITE)
+  .splice_write = iter_file_splice_write,
+# else
   .splice_write = generic_file_splice_write,
+# endif
   .splice_read = generic_file_splice_read,
 #endif
   .release =	afs_linux_release,
commit f3c0f74186f4a323ffc5f125d961fe384d396cac
Author: Marc Dionne <marc.dionne@your-file-system.com>
Date:   Wed Jun 18 09:06:39 2014 -0400

    Linux 3.16: Convert to new write_iter/read_iter ops
    
    Change read/write operations to the new write_iter/read_iter
    operations.
    
    Reviewed-on: http://gerrit.openafs.org/11303
    Reviewed-by: Chas Williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
    Tested-by: Chas Williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
    Reviewed-by: Jeffrey Altman <jaltman@your-file-system.com>
    Tested-by: Jeffrey Altman <jaltman@your-file-system.com>
    (cherry picked from commit a303bb257ed9e790d8c14644779e9508167887b6)
    
    Change-Id: I3f66104be067698a4724ed78537765cf26d4aa10
    Reviewed-on: http://gerrit.openafs.org/11309
    Reviewed-by: Chas Williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Stephan Wiesand <stephan.wiesand@desy.de>

diff --git a/acinclude.m4 b/acinclude.m4
index 83a1a8c..13d70db 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -836,6 +836,7 @@ case $AFS_SYSNAME in *_linux* | *_umlinux*)
 		 AC_CHECK_LINUX_STRUCT([inode], [i_security], [fs.h])
 		 AC_CHECK_LINUX_STRUCT([file_operations], [flock], [fs.h])
 		 AC_CHECK_LINUX_STRUCT([file_operations], [iterate], [fs.h])
+		 AC_CHECK_LINUX_STRUCT([file_operations], [read_iter], [fs.h])
 		 AC_CHECK_LINUX_STRUCT([file_operations], [sendfile], [fs.h])
 		 AC_CHECK_LINUX_STRUCT([file_system_type], [mount], [fs.h])
 		 AC_CHECK_LINUX_STRUCT([inode_operations], [truncate], [fs.h])
diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index 441cce7..818debe 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -99,8 +99,11 @@ afs_linux_VerifyVCache(struct vcache *avc, cred_t **retcred) {
     return afs_convert_code(code);
 }
 
-#ifdef HAVE_LINUX_GENERIC_FILE_AIO_READ
-# ifdef LINUX_HAS_NONVECTOR_AIO
+#if defined(STRUCT_FILE_OPERATIONS_HAS_READ_ITER) || defined(HAVE_LINUX_GENERIC_FILE_AIO_READ)
+# if defined(STRUCT_FILE_OPERATIONS_HAS_READ_ITER)
+static ssize_t
+afs_linux_read_iter(struct kiocb *iocb, struct iov_iter *iter)
+# elif defined(LINUX_HAS_NONVECTOR_AIO)
 static ssize_t
 afs_linux_aio_read(struct kiocb *iocb, char __user *buf, size_t bufsize,
                    loff_t pos)
@@ -113,6 +116,11 @@ afs_linux_aio_read(struct kiocb *iocb, const struct iovec *buf,
     struct file *fp = iocb->ki_filp;
     ssize_t code = 0;
     struct vcache *vcp = VTOAFS(fp->f_dentry->d_inode);
+# if defined(STRUCT_FILE_OPERATIONS_HAS_READ_ITER)
+    loff_t pos = iocb->ki_pos;
+    unsigned long bufsize = iter->nr_segs;
+# endif
+
 
     AFS_GLOCK();
     afs_Trace4(afs_iclSetp, CM_TRACE_AIOREADOP, ICL_TYPE_POINTER, vcp,
@@ -125,7 +133,11 @@ afs_linux_aio_read(struct kiocb *iocb, const struct iovec *buf,
 	 * so we optimise by not using it */
 	osi_FlushPages(vcp, NULL);	/* ensure stale pages are gone */
 	AFS_GUNLOCK();
+# if defined(STRUCT_FILE_OPERATIONS_HAS_READ_ITER)
+	code = generic_file_read_iter(iocb, iter);
+# else
 	code = generic_file_aio_read(iocb, buf, bufsize, pos);
+# endif
 	AFS_GLOCK();
     }
 
@@ -170,8 +182,11 @@ afs_linux_read(struct file *fp, char *buf, size_t count, loff_t * offp)
  * also take care of re-positioning the pointer if file is open in append
  * mode. Call fake open/close to ensure we do writes of core dumps.
  */
-#ifdef HAVE_LINUX_GENERIC_FILE_AIO_READ
-# ifdef LINUX_HAS_NONVECTOR_AIO
+#if defined(STRUCT_FILE_OPERATIONS_HAS_READ_ITER) || defined(HAVE_LINUX_GENERIC_FILE_AIO_READ)
+# if defined(STRUCT_FILE_OPERATIONS_HAS_READ_ITER)
+static ssize_t
+afs_linux_write_iter(struct kiocb *iocb, struct iov_iter *iter)
+# elif defined(LINUX_HAS_NONVECTOR_AIO)
 static ssize_t
 afs_linux_aio_write(struct kiocb *iocb, const char __user *buf, size_t bufsize,
                     loff_t pos)
@@ -184,6 +199,10 @@ afs_linux_aio_write(struct kiocb *iocb, const struct iovec *buf,
     ssize_t code = 0;
     struct vcache *vcp = VTOAFS(iocb->ki_filp->f_dentry->d_inode);
     cred_t *credp;
+# if defined(STRUCT_FILE_OPERATIONS_HAS_READ_ITER)
+    loff_t pos = iocb->ki_pos;
+    unsigned long bufsize = iter->nr_segs;
+# endif
 
     AFS_GLOCK();
 
@@ -199,7 +218,11 @@ afs_linux_aio_write(struct kiocb *iocb, const struct iovec *buf,
     ReleaseWriteLock(&vcp->lock);
     if (code == 0) {
 	    AFS_GUNLOCK();
+# if defined(STRUCT_FILE_OPERATIONS_HAS_READ_ITER)
+	    code = generic_file_write_iter(iocb, iter);
+# else
 	    code = generic_file_aio_write(iocb, buf, bufsize, pos);
+# endif
 	    AFS_GLOCK();
     }
 
@@ -788,7 +811,12 @@ struct file_operations afs_dir_fops = {
 };
 
 struct file_operations afs_file_fops = {
-#ifdef HAVE_LINUX_GENERIC_FILE_AIO_READ
+#ifdef STRUCT_FILE_OPERATIONS_HAS_READ_ITER
+  .read_iter =	afs_linux_read_iter,
+  .write_iter =	afs_linux_write_iter,
+  .read =	new_sync_read,
+  .write =	new_sync_write,
+#elif defined(HAVE_LINUX_GENERIC_FILE_AIO_READ)
   .aio_read =	afs_linux_aio_read,
   .aio_write =	afs_linux_aio_write,
   .read =	do_sync_read,
